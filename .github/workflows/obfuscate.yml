name: Obfuscate and Report Result

on:
  repository_dispatch:
    types: [obfuscate_code]

jobs:
  run_obfuscator:
    runs-on: ubuntu-latest
    
    # Check if the event payload contains the necessary user_code (your Lua script)
    if: github.event.client_payload.user_code
    
    # Variables that will be used throughout the steps
    env:
      USER_CODE: ${{ github.event.client_payload.user_code }}
      PROM_PRESET: ${{ github.event.client_payload.prom_preset }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup LuaJIT environment
      uses: leafo/gh-actions-luajit@v1

    - name: Run Obfuscator
      id: run_obfuscator
      run: |
        # Use a more robust way to capture multiline output and exit code.
        # Generate unique delimiters to prevent output contamination from large, complex code.
        DELIM_RESULT=$(openssl rand -hex 16)
        DELIM_ERROR=$(openssl rand -hex 16)
        
        # Make the runner executable
        chmod +x ./runner.lua || true
        
        # We execute the script and capture its stdout and stderr.
        # stderr is redirected to a file, which we will read if the script fails
        # stdout is captured by the OUTPUT variable
        # '|| true' at the end ensures this step 'succeeds' even if luajit fails,
        # so we can check its exit code in the next steps.
        OUTPUT=$(luajit ./runner.lua 2> stderr.log)
        
        # Store the exit code
        echo "exit_code=$?" >> $GITHUB_ENV
        
        # Store the stdout as a step output
        echo "result<<$DELIM_RESULT" >> $GITHUB_OUTPUT
        echo "$OUTPUT" >> $GITHUB_OUTPUT
        echo "$DELIM_RESULT" >> $GITHUB_OUTPUT
        
        # Store the stderr as a step output
        echo "error_log<<$DELIM_ERROR" >> $GITHUB_OUTPUT
        cat stderr.log >> $GITHUB_OUTPUT
        echo "$DELIM_ERROR" >> $GITHUB_OUTPUT

    - name: Report Success to Vercel
      # Only run if the obfuscator script returned success (exit code 0)
      if: env.exit_code == 0
      env:
        JOB_ID: ${{ github.event.client_payload.job_id }}
        VERCEL_WEBHOOK_URL: ${{ secrets.VERCEL_COMPLETE_URL }}
        WORKER_SECRET: ${{ secrets.WORKER_SECRET }}
        OBFUSCATED_CODE: ${{ steps.run_obfuscator.outputs.result }}
      run: |
        # Trim only leading/trailing whitespace/newlines from secrets/variables for safety
        VERCEL_WEBHOOK_URL="$(printf '%s' "$VERCEL_WEBHOOK_URL" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
        WORKER_SECRET="$(printf '%s' "$WORKER_SECRET" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
        
        echo "--- DIAGNOSTIC START ---"
        # CRITICAL CHECK: Is the jobId being received?
        printf "JOB_ID_RECEIVED: %.50s\n" "$JOB_ID"
        printf "VERCEL_URL_LENGTH: %d\n" "${#VERCEL_WEBHOOK_URL}"
        printf "WORKER_SECRET_START: %.8s\n" "$WORKER_SECRET"
        echo "--- DIAGNOSTIC END ---"

        # Write the obfuscated code to a temporary file
        echo "$OBFUSCATED_CODE" > obfuscated_code.txt
        
        # Use jq to build the JSON payload, safely reading the large file with --rawfile
        # This prevents shell quoting/truncation issues with massive output.
        jq -n \
          --arg jid "$JOB_ID" \
          --rawfile code obfuscated_code.txt \
          '{ "jobId": $jid, "status": "COMPLETED", "obfuscatedCode": $code, "error": null }' > payload.json
        
        # Post the file to Vercel
        curl -f --show-error --url "$VERCEL_WEBHOOK_URL" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $WORKER_SECRET" \
          --data-binary @payload.json
          
    - name: Report Failure to Vercel
      # Only run if the obfuscator script returned failure (exit code not 0)
      if: env.exit_code != 0
      env:
        JOB_ID: ${{ github.event.client_payload.job_id }}
        VERCEL_WEBHOOK_URL: ${{ secrets.VERCEL_COMPLETE_URL }}
        WORKER_SECRET: ${{ secrets.WORKER_SECRET }}
        ERROR_LOG: ${{ steps.run_obfuscator.outputs.error_log }}
      run: |
        # Trim only leading/trailing whitespace/newlines from secrets/variables for safety
        VERCEL_WEBHOOK_URL="$(printf '%s' "$VERCEL_WEBHOOK_URL" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
        WORKER_SECRET="$(printf '%s' "$WORKER_SECRET" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"

        # Use jq to build the JSON payload, escaping the error log
        jq -n \
          --arg jid "$JOB_ID" \
          --arg error "$ERROR_LOG" \
          '{ "jobId": $jid, "status": "FAILED", "obfuscatedCode": null, "error": $error }' > payload.json

        # Post the file to Vercel
        curl -f --show-error --url "$VERCEL_WEBHOOK_URL" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $WORKER_SECRET" \
          --data-binary @payload.json
